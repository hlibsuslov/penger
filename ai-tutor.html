<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no, date=no, email=no, address=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#FAFAFA">
  <meta name="referrer" content="no-referrer">
  <meta name="description" content="AI Tutor &mdash; Learn crypto self-custody interactively with PENGER's guided chat tutor.">
  <meta name="author" content="PENGER">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">

  <!-- Chat-layout overrides: flex shell + keyboard -->
  <style>
    :root { --kb: 0px; }

    html {
      height: 100dvh;
      height: 100vh;                       /* fallback */
      height: -webkit-fill-available;       /* older Safari */
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100dvh;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      margin: 0;
      overflow: hidden;                     /* no window scroll */
    }

    .site-header { flex-shrink: 0; }

    main {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }
    main > .section-intro { flex-shrink: 0; }
    main > .section-block {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }
    main > .section-block > .container {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }

    /* Scrollable messages container */
    #tutorChat {
      flex: 1 1 0%;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;    /* momentum scroll on older iOS */
      overscroll-behavior-y: contain;       /* no scroll-chain to body      */
      touch-action: pan-y;                  /* let browser know: vertical swipe = scroll */
      /* room for the fixed composer + safe-area + keyboard */
      padding-bottom: calc(80px + env(safe-area-inset-bottom, 0px) + var(--kb));
    }

    /* Fixed composer driven by --kb */
    .tutor-input-bar {
      position: fixed !important;
      left: 0; right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + var(--kb)) !important;
      z-index: 100;
    }

    /* 16 px prevents iOS auto-zoom on focus */
    .tutor-input { font-size: 16px !important; }
  </style>

  <title>AI Tutor &mdash; PENGER</title>
</head>
<body>

  <!-- ===== HEADER ===== -->
  <header class="site-header">
    <div class="container">
      <a href="index.html" class="site-logo"><img src="PENGER.svg" alt="PENGER" height="20"></a>
      <nav class="site-nav" id="siteNav">
        <a href="index.html" class="nav-link">Home</a>
        <a href="simulators.html" class="nav-link">Simulators</a>
        <a href="dictionary.html" class="nav-link">Dictionary</a>
        <a href="guides.html" class="nav-link">Academy</a>
        <a href="ai-tutor.html" class="nav-link">AI Tutor</a>
      </nav>
      <div class="header-controls">
        <button class="nav-hamburger" id="navHamburger" type="button" aria-label="Menu" aria-expanded="false">
          <span class="hamburger-line"></span>
          <span class="hamburger-line"></span>
          <span class="hamburger-line"></span>
        </button>
      </div>
    </div>
  </header>
  <div class="nav-overlay" id="navOverlay"></div>

  <main>
    <!-- SECTION INTRO -->
    <section class="section-intro">
      <div class="container">
        <p class="label">[ INTERACTIVE LEARNING ]</p>
        <h1>AI Tutor</h1>
        <p class="body-text">
          Learn crypto self-custody step by step. Pick a topic and follow the guided conversation &mdash; the tutor will walk you through key concepts at your own pace.
        </p>
      </div>
    </section>

    <!-- CHAT SECTION -->
    <section class="section-block" style="border-bottom:none;">
      <div class="container">
        <div class="tutor-chat" id="tutorChat">
          <!-- Messages are rendered here by JS -->
        </div>
      </div>
    </section>
  </main>

  <!-- INPUT BAR (fixed at bottom) -->
  <div class="tutor-input-bar" id="tutorInputBar">
    <div class="container">
      <div class="tutor-input-wrap">
        <input class="tutor-input" id="tutorInput" type="text" placeholder="Ask about wallets, seed phrases, blockchain..." maxlength="1000" autocomplete="off" enterkeyhint="send" inputmode="text">
        <button class="tutor-send-btn" id="tutorSendBtn" type="button" disabled aria-label="Send">
          <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M3 9h12M11 5l4 4-4 4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
      </div>
    </div>
  </div>

  <script src="shared.js"></script>
  <script>
  (function () {
    'use strict';

    /* =========================================================
       DOM REFS
       ========================================================= */
    var chatEl = document.getElementById('tutorChat');
    var activeTimer = null;
    var SCENARIOS = null;
    var history = [];       // breadcrumb: array of scenario keys visited
    var isTyping = false;   // lock to prevent clicking during typewriter

    /* =========================================================
       LOAD SCENARIOS FROM EXTERNAL JSON
       Works both via http:// server and file:// protocol.
       ========================================================= */
    function loadScenarios(cb) {
      /* --- try fetch first (works on http/https) --- */
      if (window.fetch) {
        fetch('tutor-scenarios.json')
          .then(function (r) {
            if (!r.ok) throw new Error(r.status);
            return r.json();
          })
          .then(function (data) { SCENARIOS = data; cb(null); })
          .catch(function () { fallbackXHR(cb); });
        return;
      }
      fallbackXHR(cb);
    }

    function fallbackXHR(cb) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'tutor-scenarios.json', true);
        xhr.onload = function () {
          try {
            SCENARIOS = JSON.parse(xhr.responseText);
            cb(null);
          } catch (e) { cb('Failed to parse scenarios.'); }
        };
        xhr.onerror = function () { cb('Network error. Open via a local server or use Live Server extension.'); };
        xhr.send();
      } catch (e) {
        cb('Cannot load scenarios via file:// protocol. Please open through a local server (e.g. Live Server).');
      }
    }

    /* =========================================================
       HELPERS
       ========================================================= */
    function smoothScroll() {
      chatEl.scrollTo({ top: chatEl.scrollHeight, behavior: 'smooth' });
    }

    function typeText(el, text, cb) {
      isTyping = true;
      var chars = text.split('');
      var idx = 0;
      var cursor = document.createElement('span');
      cursor.className = 'tutor-cursor';
      el.appendChild(cursor);

      // Scroll every N chars instead of every char for smoother experience
      var scrollCounter = 0;

      activeTimer = setInterval(function () {
        if (idx >= chars.length) {
          clearInterval(activeTimer);
          activeTimer = null;
          cursor.remove();
          isTyping = false;
          if (cb) cb();
          return;
        }
        var ch = chars[idx];
        if (ch === '\n') {
          cursor.insertAdjacentHTML('beforebegin', '<br>');
        } else {
          cursor.insertAdjacentText('beforebegin', ch);
        }
        idx++;
        scrollCounter++;
        if (scrollCounter % 5 === 0) chatEl.scrollTop = chatEl.scrollHeight;
      }, 12);
    }

    /* =========================================================
       BREADCRUMB
       ========================================================= */
    function renderBreadcrumb() {
      var existing = chatEl.querySelector('.tutor-breadcrumb');
      if (existing) existing.remove();
      if (history.length <= 1) return; // don't show on root

      var bc = document.createElement('div');
      bc.className = 'tutor-breadcrumb';

      var homeBtn = document.createElement('button');
      homeBtn.type = 'button';
      homeBtn.className = 'tutor-bc-item tutor-bc-home';
      homeBtn.textContent = 'Start';
      homeBtn.addEventListener('click', function () {
        if (isTyping) return;
        startChat();
      });
      bc.appendChild(homeBtn);

      // Show depth indicator
      for (var i = 1; i < history.length; i++) {
        var sep = document.createElement('span');
        sep.className = 'tutor-bc-sep';
        sep.textContent = '\u203A';
        bc.appendChild(sep);

        var label = document.createElement('span');
        label.className = 'tutor-bc-item';
        label.textContent = formatBcLabel(history[i]);
        bc.appendChild(label);
      }

      chatEl.insertBefore(bc, chatEl.firstChild);
    }

    function formatBcLabel(key) {
      // Convert "wallet_intro" -> "Intro", "seed_bip39" -> "BIP39"
      var parts = key.split('_');
      var label = parts.length > 1 ? parts.slice(1).join(' ') : parts[0];
      return label.charAt(0).toUpperCase() + label.slice(1);
    }

    /* =========================================================
       RENDER MESSAGES
       ========================================================= */
    function addUserMsg(text) {
      var div = document.createElement('div');
      div.className = 'tutor-msg user';
      div.textContent = text;
      chatEl.appendChild(div);
      smoothScroll();
    }

    function addBotMsg(scenarioKey) {
      if (!SCENARIOS) return;
      var scene = SCENARIOS[scenarioKey];
      if (!scene) return;

      // Track history
      history.push(scenarioKey);
      chatEl.setAttribute('data-scenario', scenarioKey);
      renderBreadcrumb();

      // Typing indicator
      var indicator = document.createElement('div');
      indicator.className = 'tutor-msg bot tutor-typing-msg';
      indicator.innerHTML = '<span class="tutor-typing"><span></span><span></span><span></span></span>';
      chatEl.appendChild(indicator);
      smoothScroll();

      setTimeout(function () {
        indicator.remove();

        // Bot bubble
        var div = document.createElement('div');
        div.className = 'tutor-msg bot';
        var textWrap = document.createElement('div');
        textWrap.className = 'tutor-msg-text';
        div.appendChild(textWrap);
        chatEl.appendChild(div);
        smoothScroll();

        typeText(textWrap, scene.bot, function () {
          if (scene.options && scene.options.length > 0) {
            var optWrap = document.createElement('div');
            optWrap.className = 'tutor-options';

            scene.options.forEach(function (opt) {
              var btn = document.createElement('button');
              btn.className = 'tutor-option-btn';
              btn.type = 'button';
              btn.textContent = opt.label;

              if (opt.next === 'root') {
                btn.classList.add('restart');
                btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="vertical-align:-2px;margin-right:6px;"><path d="M4 12a8 8 0 0 1 13.4-5.9L20 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20 4v5h-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20 12a8 8 0 0 1-13.4 5.9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 20v-5h5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>' + opt.label;
              }

              btn.addEventListener('click', function () {
                if (isTyping) return;

                optWrap.querySelectorAll('.tutor-option-btn').forEach(function (b) {
                  b.disabled = true;
                  if (b !== btn) b.classList.add('dimmed');
                  else b.classList.add('chosen');
                });

                if (opt.next === 'root') {
                  setTimeout(function () { startChat(); }, 300);
                } else {
                  addUserMsg(opt.label);
                  setTimeout(function () { addBotMsg(opt.next); }, 400);
                }
              });

              optWrap.appendChild(btn);
            });

            div.appendChild(optWrap);
            smoothScroll();
          }
        });
      }, 600);
    }

    /* =========================================================
       START / RESET
       ========================================================= */
    function startChat() {
      if (activeTimer) { clearInterval(activeTimer); activeTimer = null; }
      isTyping = false;
      history = [];
      chatEl.innerHTML = '';
      addBotMsg('root');
    }

    /* =========================================================
       ERROR STATE
       ========================================================= */
    function showError(msg) {
      chatEl.innerHTML = '<div class="tutor-msg bot" style="color:var(--error-text);border-color:var(--error-border);">' + msg + ' <button class="tutor-option-btn" onclick="location.reload()" type="button" style="margin-top:10px;">Retry</button></div>';
    }

    /* =========================================================
       INIT
       ========================================================= */
    loadScenarios(function (err) {
      if (err) { showError(err); return; }
      startChat();
    });
  })();

  /* =================================================================
     FREE-TEXT CHAT ENGINE
     Adds OpenAI-powered free input alongside the scenario system.
     Communicates with a Cloudflare Worker proxy at TUTOR_API.endpoint.
     ================================================================= */
  (function () {
    'use strict';

    /* === CONFIG === */
    var TUTOR_API = {
      endpoint: '/api/chat',
      maxHistoryMessages: 10,
      maxInputLength: 1000,
      retryDelay: 2000,
    };

    /* === DOM REFS === */
    var chatEl  = document.getElementById('tutorChat');
    var inputEl = document.getElementById('tutorInput');
    var sendBtn = document.getElementById('tutorSendBtn');
    if (!chatEl || !inputEl || !sendBtn) return;

    /* === STATE === */
    var conversationHistory = [];
    var isSending = false;

    /* === CONTEXT BRIDGE ===
       Read current scenario from data attribute set by scenario IIFE */
    function getCurrentContext() {
      return chatEl.getAttribute('data-scenario') || null;
    }

    /* === MUTATION OBSERVER ===
       Reset conversation history when scenario engine clears the chat */
    var observer = new MutationObserver(function () {
      if (chatEl.childNodes.length === 0 ||
          (chatEl.childNodes.length <= 2 && chatEl.querySelector('.tutor-breadcrumb'))) {
        conversationHistory = [];
      }
    });
    observer.observe(chatEl, { childList: true });

    /* === INPUT HANDLING === */
    function updateSendButton() {
      var hasText = inputEl.value.trim().length > 0;
      sendBtn.disabled = !hasText || isSending || !TUTOR_API.endpoint;
    }

    inputEl.addEventListener('input', updateSendButton);
    inputEl.addEventListener('keydown', function (e) {
      if ((e.key === 'Enter' || e.keyCode === 13) && !e.shiftKey && !sendBtn.disabled) {
        e.preventDefault();
        handleSend();
      }
    });
    sendBtn.addEventListener('click', function () {
      if (!sendBtn.disabled) handleSend();
    });

    /* === SANITIZE === */
    function sanitizeInput(text) {
      text = text.replace(/<[^>]*>/g, '');
      text = text.replace(/\s{3,}/g, '  ');
      if (text.length > TUTOR_API.maxInputLength) {
        text = text.slice(0, TUTOR_API.maxInputLength);
      }
      return text.trim();
    }

    /* === HISTORY TRIM === */
    function trimHistory() {
      while (conversationHistory.length > TUTOR_API.maxHistoryMessages) {
        conversationHistory.shift();
      }
    }

    /* === SMOOTH SCROLL === */
    function smoothScroll() {
      chatEl.scrollTo({ top: chatEl.scrollHeight, behavior: 'smooth' });
    }

    /* === TYPEWRITER WITH INLINE MARKDOWN === */
    function typeTextFree(el, text, cb) {
      /* Strip unmatched ** so they never appear as raw asterisks.
         If ** count is odd, the last unpaired ** is removed. */
      var markerCount = (text.match(/\*\*/g) || []).length;
      if (markerCount % 2 !== 0) {
        var lastUnpaired = text.lastIndexOf('**');
        text = text.slice(0, lastUnpaired) + text.slice(lastUnpaired + 2);
      }

      /* Pre-parse text into plain / bold segments so **bold** renders
         in real-time instead of showing raw asterisks first. */
      var segments = [];
      var re = /\*\*(.+?)\*\*/g;
      var last = 0;
      var m;
      while ((m = re.exec(text)) !== null) {
        if (m.index > last) segments.push({ b: false, t: text.slice(last, m.index) });
        segments.push({ b: true, t: m[1] });
        last = re.lastIndex;
      }
      if (last < text.length) segments.push({ b: false, t: text.slice(last) });

      /* Flatten into a char queue with bold flag */
      var queue = [];
      segments.forEach(function (s) {
        for (var i = 0; i < s.t.length; i++) {
          queue.push({ ch: s.t[i], b: s.b });
        }
      });

      var idx = 0;
      var cursor = document.createElement('span');
      cursor.className = 'tutor-cursor';
      el.appendChild(cursor);
      var scrollCounter = 0;
      var strong = null;

      var timer = setInterval(function () {
        if (idx >= queue.length) {
          clearInterval(timer);
          cursor.remove();
          if (cb) cb();
          return;
        }
        var item = queue[idx];
        if (item.ch === '\n') {
          strong = null;
          cursor.insertAdjacentHTML('beforebegin', '<br>');
        } else if (item.b) {
          if (!strong) {
            strong = document.createElement('strong');
            cursor.insertAdjacentElement('beforebegin', strong);
          }
          strong.appendChild(document.createTextNode(item.ch));
        } else {
          strong = null;
          cursor.insertAdjacentText('beforebegin', item.ch);
        }
        idx++;
        scrollCounter++;
        if (scrollCounter % 5 === 0) chatEl.scrollTop = chatEl.scrollHeight;
      }, 12);
    }

    /* === TYPING INDICATOR === */
    function showTypingIndicator() {
      var div = document.createElement('div');
      div.className = 'tutor-msg bot tutor-typing-msg';
      div.innerHTML = '<span class="tutor-typing"><span></span><span></span><span></span></span>';
      chatEl.appendChild(div);
      smoothScroll();
      return div;
    }

    function removeTypingIndicator(el) {
      if (el && el.parentNode) el.remove();
    }

    /* === MESSAGE BUBBLES === */
    function addFreeUserMsg(text) {
      var div = document.createElement('div');
      div.className = 'tutor-msg user';
      div.textContent = text;
      chatEl.appendChild(div);
      smoothScroll();
    }

    function addFreeBotMsg(text, cb) {
      var div = document.createElement('div');
      div.className = 'tutor-msg bot';
      var textWrap = document.createElement('div');
      textWrap.className = 'tutor-msg-text';
      div.appendChild(textWrap);
      chatEl.appendChild(div);
      smoothScroll();

      typeTextFree(textWrap, text, function () {
        if (cb) cb();
      });
    }

    function addErrorMsg(text) {
      var div = document.createElement('div');
      div.className = 'tutor-msg bot tutor-error-msg';
      div.textContent = text;
      chatEl.appendChild(div);
      smoothScroll();
    }

    /* === API CALL === */
    function callTutorAPI(messages, context) {
      var payload = { messages: messages };
      if (context) payload.context = context;

      return fetch(TUTOR_API.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })
      .then(function (res) {
        if (res.ok) return res.json();
        return res.json().catch(function () { return {}; }).then(function (d) {
          if (res.status === 429) throw new Error(d.error || 'You\'re sending messages too fast. Please wait a minute.');
          if (res.status === 503) throw new Error(d.error || 'AI service is temporarily unavailable.');
          if (res.status === 400) throw new Error(d.error || 'Invalid request.');
          throw new Error(d.error || 'Something went wrong. Please try again.');
        });
      })
      .then(function (data) {
        if (!data.reply) throw new Error('Empty response from AI.');
        return data.reply;
      });
    }

    /* === SEND FLOW === */
    function handleSend() {
      var text = sanitizeInput(inputEl.value);
      if (!text || isSending) return;

      isSending = true;
      inputEl.value = '';
      updateSendButton();
      inputEl.focus();

      var context = getCurrentContext();

      addFreeUserMsg(text);
      conversationHistory.push({ role: 'user', content: text });
      trimHistory();

      var typingEl = showTypingIndicator();

      callTutorAPI(conversationHistory, context)
        .then(function (reply) {
          removeTypingIndicator(typingEl);
          addFreeBotMsg(reply, function () {
            conversationHistory.push({ role: 'assistant', content: reply });
            trimHistory();
            isSending = false;
            updateSendButton();
          });
        })
        .catch(function (err) {
          removeTypingIndicator(typingEl);
          addErrorMsg(err.message || 'Connection error. Please try again.');
          isSending = false;
          updateSendButton();
        });
    }

    /* === MOBILE KEYBOARD HANDLING v3 ===

       How it works
       ------------
       The composer (.tutor-input-bar) is position:fixed with:
         bottom: calc(env(safe-area-inset-bottom) + var(--kb, 0px))
       The #tutorChat container has matching padding-bottom so the
       last message is always scrollable above the composer.

       On every visualViewport resize/scroll we compute:
         kb = max(0, innerHeight − (vv.height + vv.offsetTop))
       and write it into the CSS custom property --kb on <html>.

       Why this formula is correct:
       • innerHeight  = layout viewport height  (fixed on iOS)
       • vv.height    = visible viewport height  (shrinks when KB opens)
       • vv.offsetTop = scroll offset of the visual viewport inside
         the layout viewport (accounts for URL-bar toggle & scroll)
       • The result is exactly the number of pixels the keyboard
         "ate" from the bottom — works on both iOS and Android.
       • Math.max(0, …) clamps rubber-band / overscroll negatives.

       Platform behaviour:
       • iOS Safari:   layout viewport unchanged → --kb drives shift.
       • Android Chrome: layout viewport resizes → vv.height ≈
         innerHeight → kb ≈ 0 → no double-shift.

       Extra touches:
       • font-size:16px on input prevents iOS auto-zoom.
       • 300 ms blur delay avoids flicker when tapping Send.
       • touchmove prevented on the bar to block accidental drag.
       • orientationchange resets --kb after viewport settles.
       ============================================================ */

    var inputBar = document.getElementById('tutorInputBar');

    (function initKeyboardHandler() {
      var root = document.documentElement;
      var vv   = window.visualViewport;
      if (!vv || !inputBar) return;

      var pendingRAF = null;

      function syncKB() {
        if (pendingRAF) return;
        pendingRAF = requestAnimationFrame(function () {
          pendingRAF = null;
          var kb = Math.max(0,
            window.innerHeight - (vv.height + vv.offsetTop));
          root.style.setProperty('--kb', kb + 'px');
          if (kb > 50) smoothScroll();   // auto-scroll when kb opens
        });
      }

      vv.addEventListener('resize', syncKB);
      vv.addEventListener('scroll', syncKB);

      /* Focus → let keyboard animate in, then sync + scroll */
      inputEl.addEventListener('focus', function () {
        setTimeout(function () { syncKB(); smoothScroll(); }, 300);
      });

      /* Blur → delay reset so tapping Send doesn't flash */
      inputEl.addEventListener('blur', function () {
        setTimeout(function () {
          if (document.activeElement !== inputEl) {
            root.style.setProperty('--kb', '0px');
          }
        }, 300);
      });

      /* Orientation change → full reset after viewport settles */
      window.addEventListener('orientationchange', function () {
        setTimeout(function () {
          root.style.setProperty('--kb', '0px');
        }, 500);
      });
    })();

    /* Prevent touch-drag on input bar */
    if (inputBar) {
      inputBar.addEventListener('touchmove', function (e) {
        e.preventDefault();
      }, { passive: false });
    }

    /* === INIT === */
    updateSendButton();
  })();
  </script>
</body>
</html>
